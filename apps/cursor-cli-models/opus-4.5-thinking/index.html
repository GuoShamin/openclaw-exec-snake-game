<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è‡ªåŠ¨é©¾é©¶è´ªåƒè›‡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #fff;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 20px;
            max-width: 100vw;
        }
        
        h1 {
            font-size: clamp(1.2rem, 5vw, 1.8rem);
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            color: #00ff88;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            font-size: clamp(0.9rem, 3vw, 1.1rem);
        }
        
        .stats span {
            background: rgba(255,255,255,0.1);
            padding: 8px 16px;
            border-radius: 20px;
        }
        
        #gameCanvas {
            border: 3px solid #00ff88;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            max-width: calc(100vw - 40px);
            max-height: calc(100vh - 200px);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            border-radius: 25px;
            cursor: pointer;
            color: #1a1a2e;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        .info {
            font-size: clamp(0.7rem, 2.5vw, 0.85rem);
            color: rgba(255,255,255,0.6);
            text-align: center;
            max-width: 400px;
        }
        
        .status {
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.9rem;
        }
        
        .status.auto {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }
        
        .status.manual {
            background: rgba(255, 200, 0, 0.2);
            color: #ffc800;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ è‡ªåŠ¨é©¾é©¶è´ªåƒè›‡</h1>
        <div class="stats">
            <span>å¾—åˆ†: <strong id="score">0</strong></span>
            <span>æœ€é«˜: <strong id="highScore">0</strong></span>
            <span class="status auto" id="modeStatus">è‡ªåŠ¨æ¨¡å¼</span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <button id="toggleBtn">åˆ‡æ¢æ‰‹åŠ¨</button>
            <button id="restartBtn">é‡æ–°å¼€å§‹</button>
            <button id="speedBtn">é€Ÿåº¦: æ­£å¸¸</button>
        </div>
        <p class="info">
            è‡ªåŠ¨æ¨¡å¼ä¸‹è›‡ä¼šè‡ªåŠ¨å¯»æ‰¾é£Ÿç‰©å¹¶é¿å¼€éšœç¢ã€‚<br>
            æ‰‹åŠ¨æ¨¡å¼ï¼šæ–¹å‘é”®/WASD/è§¦å±æ»‘åŠ¨æ§åˆ¶ã€‚
        </p>
    </div>

    <script>
        /**
         * è‡ªåŠ¨é©¾é©¶è´ªåƒè›‡ - AIç­–ç•¥è¯´æ˜
         * ================================
         * é‡‡ç”¨ BFS + å®‰å…¨æ£€æŸ¥ + è¿½å°¾ç­–ç•¥ çš„æ··åˆæ–¹æ¡ˆï¼š
         * 
         * 1. BFSå¯»è·¯ï¼šä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢æ‰¾åˆ°è›‡å¤´åˆ°é£Ÿç‰©çš„æœ€çŸ­è·¯å¾„
         * 2. å®‰å…¨æ£€æŸ¥ï¼šåœ¨æ‰§è¡Œç§»åŠ¨å‰ï¼Œä½¿ç”¨æ´ªæ³›å¡«å……(flood fill)æ£€æŸ¥
         *    ç§»åŠ¨åè›‡å¤´èƒ½è®¿é—®çš„ç©ºé—´æ˜¯å¦è¶³å¤Ÿï¼ˆè‡³å°‘è¦èƒ½å®¹çº³è›‡èº«é•¿åº¦ï¼‰
         * 3. è¿½å°¾ç­–ç•¥ï¼šå¦‚æœç›´æ¥åƒé£Ÿç‰©çš„è·¯å¾„ä¸å®‰å…¨ï¼Œåˆ™æ”¹ä¸ºè¿½é€è‡ªå·±çš„å°¾å·´ï¼Œ
         *    è¿™æ ·å¯ä»¥ä¿æŒç§»åŠ¨åŒæ—¶ç­‰å¾…æ›´å®‰å…¨çš„æœºä¼š
         * 4. ç´§æ€¥è§„é¿ï¼šå¦‚æœè¿½å°¾ä¹Ÿä¸å¯è¡Œï¼Œé€‰æ‹©ä»»æ„å®‰å…¨æ–¹å‘ç§»åŠ¨
         * 
         * è¿™ç§ç­–ç•¥å¹³è¡¡äº†æ•ˆç‡ï¼ˆå°½å¿«åƒé£Ÿç‰©ï¼‰å’Œå®‰å…¨æ€§ï¼ˆé¿å…è‡ªæ€ï¼‰
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // å“åº”å¼ç”»å¸ƒå°ºå¯¸
        const GRID_SIZE = 20;
        let COLS, ROWS;
        
        function resizeCanvas() {
            const maxW = Math.min(600, window.innerWidth - 40);
            const maxH = Math.min(600, window.innerHeight - 250);
            const size = Math.min(maxW, maxH);
            COLS = Math.floor(size / GRID_SIZE);
            ROWS = COLS;
            canvas.width = COLS * GRID_SIZE;
            canvas.height = ROWS * GRID_SIZE;
        }
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            resetGame();
        });

        // æ¸¸æˆçŠ¶æ€
        let snake = [];
        let food = { x: 0, y: 0 };
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let score = 0;
        let highScore = parseInt(localStorage.getItem('snakeHighScore') || '0');
        let gameLoop = null;
        let autoMode = true;
        let speeds = [200, 100, 50];
        let speedIndex = 1;
        let speedNames = ['æ…¢é€Ÿ', 'æ­£å¸¸', 'å¿«é€Ÿ'];

        document.getElementById('highScore').textContent = highScore;

        // æ–¹å‘æ˜ å°„
        const DIRECTIONS = [
            { x: 0, y: -1 },  // ä¸Š
            { x: 0, y: 1 },   // ä¸‹
            { x: -1, y: 0 },  // å·¦
            { x: 1, y: 0 }    // å³
        ];

        function initSnake() {
            const startX = Math.floor(COLS / 2);
            const startY = Math.floor(ROWS / 2);
            snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
        }

        function spawnFood() {
            const emptyCells = [];
            for (let x = 0; x < COLS; x++) {
                for (let y = 0; y < ROWS; y++) {
                    if (!snake.some(s => s.x === x && s.y === y)) {
                        emptyCells.push({ x, y });
                    }
                }
            }
            if (emptyCells.length > 0) {
                food = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            }
        }

        function draw() {
            // èƒŒæ™¯
            ctx.fillStyle = '#0f0f23';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç½‘æ ¼çº¿ï¼ˆæ·¡ï¼‰
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * GRID_SIZE, 0);
                ctx.lineTo(x * GRID_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * GRID_SIZE);
                ctx.lineTo(canvas.width, y * GRID_SIZE);
                ctx.stroke();
            }

            // é£Ÿç‰©
            ctx.fillStyle = '#ff6b6b';
            ctx.shadowColor = '#ff6b6b';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(
                food.x * GRID_SIZE + GRID_SIZE / 2,
                food.y * GRID_SIZE + GRID_SIZE / 2,
                GRID_SIZE / 2 - 2,
                0, Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 0;

            // è›‡èº«
            snake.forEach((segment, i) => {
                const isHead = i === 0;
                const gradient = ctx.createRadialGradient(
                    segment.x * GRID_SIZE + GRID_SIZE / 2,
                    segment.y * GRID_SIZE + GRID_SIZE / 2,
                    0,
                    segment.x * GRID_SIZE + GRID_SIZE / 2,
                    segment.y * GRID_SIZE + GRID_SIZE / 2,
                    GRID_SIZE / 2
                );
                
                if (isHead) {
                    gradient.addColorStop(0, '#00ff88');
                    gradient.addColorStop(1, '#00cc6a');
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 10;
                } else {
                    const alpha = 1 - (i / snake.length) * 0.5;
                    gradient.addColorStop(0, `rgba(0, 200, 100, ${alpha})`);
                    gradient.addColorStop(1, `rgba(0, 150, 80, ${alpha})`);
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.roundRect(
                    segment.x * GRID_SIZE + 1,
                    segment.y * GRID_SIZE + 1,
                    GRID_SIZE - 2,
                    GRID_SIZE - 2,
                    isHead ? 6 : 4
                );
                ctx.fill();
                ctx.shadowBlur = 0;

                // è›‡çœ¼
                if (isHead) {
                    ctx.fillStyle = '#fff';
                    const eyeSize = 3;
                    const eyeOffset = 4;
                    let eye1, eye2;
                    
                    if (direction.x === 1) {
                        eye1 = { x: segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, y: segment.y * GRID_SIZE + eyeOffset };
                        eye2 = { x: segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, y: segment.y * GRID_SIZE + GRID_SIZE - eyeOffset };
                    } else if (direction.x === -1) {
                        eye1 = { x: segment.x * GRID_SIZE + eyeOffset, y: segment.y * GRID_SIZE + eyeOffset };
                        eye2 = { x: segment.x * GRID_SIZE + eyeOffset, y: segment.y * GRID_SIZE + GRID_SIZE - eyeOffset };
                    } else if (direction.y === -1) {
                        eye1 = { x: segment.x * GRID_SIZE + eyeOffset, y: segment.y * GRID_SIZE + eyeOffset };
                        eye2 = { x: segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, y: segment.y * GRID_SIZE + eyeOffset };
                    } else {
                        eye1 = { x: segment.x * GRID_SIZE + eyeOffset, y: segment.y * GRID_SIZE + GRID_SIZE - eyeOffset };
                        eye2 = { x: segment.x * GRID_SIZE + GRID_SIZE - eyeOffset, y: segment.y * GRID_SIZE + GRID_SIZE - eyeOffset };
                    }
                    
                    ctx.beginPath();
                    ctx.arc(eye1.x, eye1.y, eyeSize, 0, Math.PI * 2);
                    ctx.arc(eye2.x, eye2.y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // ==================== AI è‡ªåŠ¨é©¾é©¶é€»è¾‘ ====================

        function posKey(pos) {
            return `${pos.x},${pos.y}`;
        }

        function isValidPos(x, y, snakeBody) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
            return !snakeBody.some(s => s.x === x && s.y === y);
        }

        // BFS å¯»æ‰¾åˆ°ç›®æ ‡çš„è·¯å¾„
        function bfsPath(start, target, snakeBody) {
            const queue = [{ pos: start, path: [] }];
            const visited = new Set([posKey(start)]);

            while (queue.length > 0) {
                const { pos, path } = queue.shift();

                if (pos.x === target.x && pos.y === target.y) {
                    return path;
                }

                for (const dir of DIRECTIONS) {
                    const nx = pos.x + dir.x;
                    const ny = pos.y + dir.y;
                    const key = posKey({ x: nx, y: ny });

                    if (isValidPos(nx, ny, snakeBody) && !visited.has(key)) {
                        visited.add(key);
                        queue.push({
                            pos: { x: nx, y: ny },
                            path: [...path, dir]
                        });
                    }
                }
            }
            return null;
        }

        // æ´ªæ³›å¡«å……è®¡ç®—å¯è¾¾ç©ºé—´å¤§å°
        function floodFillCount(start, snakeBody) {
            const visited = new Set([posKey(start)]);
            const queue = [start];
            let count = 1;

            while (queue.length > 0) {
                const pos = queue.shift();
                for (const dir of DIRECTIONS) {
                    const nx = pos.x + dir.x;
                    const ny = pos.y + dir.y;
                    const key = posKey({ x: nx, y: ny });
                    
                    if (isValidPos(nx, ny, snakeBody) && !visited.has(key)) {
                        visited.add(key);
                        queue.push({ x: nx, y: ny });
                        count++;
                    }
                }
            }
            return count;
        }

        // æ¨¡æ‹Ÿç§»åŠ¨åçš„è›‡èº«ï¼ˆç”¨äºå®‰å…¨æ£€æŸ¥ï¼‰
        function simulateMove(dir, willEat) {
            const newHead = {
                x: snake[0].x + dir.x,
                y: snake[0].y + dir.y
            };
            const newSnake = [newHead, ...snake];
            if (!willEat) {
                newSnake.pop();
            }
            return newSnake;
        }

        // æ£€æŸ¥ç§»åŠ¨æ˜¯å¦å®‰å…¨
        function isSafeMove(dir) {
            const newHead = {
                x: snake[0].x + dir.x,
                y: snake[0].y + dir.y
            };
            
            if (!isValidPos(newHead.x, newHead.y, snake.slice(0, -1))) {
                return false;
            }

            const willEat = newHead.x === food.x && newHead.y === food.y;
            const futureSnake = simulateMove(dir, willEat);
            const futureBody = futureSnake.slice(1);
            
            const reachableSpace = floodFillCount(newHead, futureBody);
            return reachableSpace >= futureSnake.length;
        }

        // AI å†³ç­–ä¸‹ä¸€æ­¥æ–¹å‘
        function getAutoDirection() {
            const head = snake[0];
            const tail = snake[snake.length - 1];

            // ç­–ç•¥1ï¼šå°è¯•æ‰¾åˆ°é£Ÿç‰©çš„è·¯å¾„
            const pathToFood = bfsPath(head, food, snake.slice(0, -1));
            
            if (pathToFood && pathToFood.length > 0) {
                const firstMove = pathToFood[0];
                if (isSafeMove(firstMove)) {
                    return firstMove;
                }
            }

            // ç­–ç•¥2ï¼šè¿½å°¾ï¼ˆä¿æŒå­˜æ´»ç­‰å¾…æœºä¼šï¼‰
            const pathToTail = bfsPath(head, tail, snake.slice(0, -1));
            if (pathToTail && pathToTail.length > 1) {
                const firstMove = pathToTail[0];
                if (isSafeMove(firstMove)) {
                    return firstMove;
                }
            }

            // ç­–ç•¥3ï¼šé€‰æ‹©ä»»æ„å®‰å…¨æ–¹å‘
            for (const dir of DIRECTIONS) {
                if (dir.x === -direction.x && dir.y === -direction.y) continue;
                if (isSafeMove(dir)) {
                    return dir;
                }
            }

            // æ— è·¯å¯èµ°ï¼Œè¿”å›å½“å‰æ–¹å‘ï¼ˆå¯èƒ½ä¼šæ­»ï¼‰
            return direction;
        }

        // ==================== æ¸¸æˆä¸»å¾ªç¯ ====================

        function update() {
            if (autoMode) {
                nextDirection = getAutoDirection();
            }

            if (nextDirection.x !== -direction.x || nextDirection.y !== -direction.y) {
                direction = nextDirection;
            }

            const head = snake[0];
            const newHead = {
                x: head.x + direction.x,
                y: head.y + direction.y
            };

            // ç¢°æ’æ£€æµ‹
            if (newHead.x < 0 || newHead.x >= COLS ||
                newHead.y < 0 || newHead.y >= ROWS ||
                snake.some(s => s.x === newHead.x && s.y === newHead.y)) {
                gameOver();
                return;
            }

            snake.unshift(newHead);

            // åƒé£Ÿç‰©
            if (newHead.x === food.x && newHead.y === food.y) {
                score++;
                document.getElementById('score').textContent = score;
                if (score > highScore) {
                    highScore = score;
                    document.getElementById('highScore').textContent = highScore;
                    localStorage.setItem('snakeHighScore', highScore.toString());
                }
                spawnFood();
            } else {
                snake.pop();
            }

            draw();
        }

        function gameOver() {
            clearInterval(gameLoop);
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ff6b6b';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('æ¸¸æˆç»“æŸ!', canvas.width / 2, canvas.height / 2 - 15);
            ctx.fillStyle = '#fff';
            ctx.font = '16px sans-serif';
            ctx.fillText(`å¾—åˆ†: ${score}`, canvas.width / 2, canvas.height / 2 + 15);
            
            // è‡ªåŠ¨é‡å¯
            setTimeout(resetGame, 2000);
        }

        function resetGame() {
            clearInterval(gameLoop);
            score = 0;
            document.getElementById('score').textContent = score;
            initSnake();
            spawnFood();
            draw();
            gameLoop = setInterval(update, speeds[speedIndex]);
        }

        // ==================== ç”¨æˆ·è¾“å…¥å¤„ç† ====================

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (autoMode) return;
            
            const keyMap = {
                'ArrowUp': { x: 0, y: -1 }, 'w': { x: 0, y: -1 }, 'W': { x: 0, y: -1 },
                'ArrowDown': { x: 0, y: 1 }, 's': { x: 0, y: 1 }, 'S': { x: 0, y: 1 },
                'ArrowLeft': { x: -1, y: 0 }, 'a': { x: -1, y: 0 }, 'A': { x: -1, y: 0 },
                'ArrowRight': { x: 1, y: 0 }, 'd': { x: 1, y: 0 }, 'D': { x: 1, y: 0 }
            };

            if (keyMap[e.key]) {
                e.preventDefault();
                nextDirection = keyMap[e.key];
            }
        });

        // è§¦å±æ»‘åŠ¨æ§åˆ¶
        let touchStartX = 0, touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (autoMode) return;
            e.preventDefault();
            
            const dx = e.changedTouches[0].clientX - touchStartX;
            const dy = e.changedTouches[0].clientY - touchStartY;
            const threshold = 30;

            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
                nextDirection = dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 };
            } else if (Math.abs(dy) > threshold) {
                nextDirection = dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 };
            }
        }, { passive: false });

        // é˜»æ­¢é¡µé¢æ»šåŠ¨
        document.body.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        // ==================== æŒ‰é’®æ§åˆ¶ ====================

        document.getElementById('toggleBtn').addEventListener('click', () => {
            autoMode = !autoMode;
            const btn = document.getElementById('toggleBtn');
            const status = document.getElementById('modeStatus');
            btn.textContent = autoMode ? 'åˆ‡æ¢æ‰‹åŠ¨' : 'åˆ‡æ¢è‡ªåŠ¨';
            status.textContent = autoMode ? 'è‡ªåŠ¨æ¨¡å¼' : 'æ‰‹åŠ¨æ¨¡å¼';
            status.className = 'status ' + (autoMode ? 'auto' : 'manual');
        });

        document.getElementById('restartBtn').addEventListener('click', resetGame);

        document.getElementById('speedBtn').addEventListener('click', () => {
            speedIndex = (speedIndex + 1) % speeds.length;
            document.getElementById('speedBtn').textContent = `é€Ÿåº¦: ${speedNames[speedIndex]}`;
            clearInterval(gameLoop);
            gameLoop = setInterval(update, speeds[speedIndex]);
        });

        // å¯åŠ¨æ¸¸æˆ
        resetGame();
    </script>
</body>
</html>
