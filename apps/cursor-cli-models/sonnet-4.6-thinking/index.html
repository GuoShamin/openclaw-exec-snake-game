<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Snake Autopilot</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #0d1117;
      color: #e6edf3;
      font-family: 'Segoe UI', system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100dvh;
      padding: 12px;
      overflow: hidden;
      touch-action: none;
    }

    h1 {
      font-size: clamp(1.1rem, 4vw, 1.6rem);
      letter-spacing: 0.08em;
      color: #58a6ff;
      margin-bottom: 8px;
      text-shadow: 0 0 12px #1f6feb88;
    }

    #scoreboard {
      display: flex;
      gap: 24px;
      margin-bottom: 10px;
      font-size: clamp(0.8rem, 3vw, 1rem);
    }

    .score-item span {
      color: #3fb950;
      font-weight: 700;
      font-size: 1.1em;
    }

    #canvas-wrap {
      position: relative;
      border: 2px solid #30363d;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0 24px #1f6feb44;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
    }

    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #0d111799;
      backdrop-filter: blur(4px);
      gap: 12px;
    }

    #overlay h2 {
      font-size: clamp(1.2rem, 5vw, 1.8rem);
      color: #f0883e;
    }

    #overlay p {
      font-size: clamp(0.75rem, 3vw, 0.95rem);
      color: #8b949e;
      text-align: center;
      padding: 0 16px;
    }

    #btn-start {
      background: #238636;
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 10px 28px;
      font-size: clamp(0.85rem, 3.5vw, 1rem);
      cursor: pointer;
      transition: background 0.2s;
    }

    #btn-start:hover { background: #2ea043; }

    #strategy-tag {
      position: absolute;
      bottom: 6px;
      right: 8px;
      font-size: 0.65rem;
      color: #484f58;
    }
  </style>
</head>
<body>
  <h1>ğŸ Snake Autopilot</h1>
  <div id="scoreboard">
    <div class="score-item">å¾—åˆ† <span id="score">0</span></div>
    <div class="score-item">æœ€é«˜ <span id="best">0</span></div>
    <div class="score-item">å±€æ•° <span id="games">0</span></div>
  </div>
  <div id="canvas-wrap">
    <canvas id="c"></canvas>
    <div id="overlay">
      <h2>Snake Autopilot</h2>
      <p>AI å°†è‡ªåŠ¨é©¾é©¶è´ªåƒè›‡<br>ç­–ç•¥ï¼šBFS æœ€çŸ­è·¯å¾„ + å®‰å…¨æ€§æ£€æµ‹ + è¿½å°¾å…œåº•</p>
      <button id="btn-start">å¼€å§‹è§‚çœ‹</button>
    </div>
    <div id="strategy-tag">BFS + Safety Check</div>
  </div>

  <script>
  /*
   * è‡ªåŠ¨é©¾é©¶ç­–ç•¥è¯´æ˜
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   * ä¼˜å…ˆçº§ 1 â€” å®‰å…¨ BFS åˆ°é£Ÿç‰©
   *   ç”¨ BFS æ‰¾è›‡å¤´åˆ°é£Ÿç‰©çš„æœ€çŸ­è·¯å¾„ï¼Œç„¶å"æ¨¡æ‹Ÿ"è›‡æ²¿è¯¥è·¯å¾„èµ°å®Œåï¼Œ
   *   å†æ£€æŸ¥è›‡å¤´ï¼ˆæ­¤æ—¶å·²åˆ°è¾¾é£Ÿç‰©ä½ç½®ï¼‰èƒ½å¦ç”¨ BFS åˆ°è¾¾è‡ªèº«å°¾å·´ã€‚
   *   è‹¥èƒ½åˆ°è¾¾ï¼ˆè¯´æ˜èµ°å®Œåä¸ä¼šè¢«å›°æ­»ï¼‰ï¼Œåˆ™é‡‡ç”¨æ­¤è·¯å¾„çš„ç¬¬ä¸€æ­¥ã€‚
   *
   * ä¼˜å…ˆçº§ 2 â€” è¿½å°¾ï¼ˆtail-chasingï¼‰
   *   è‹¥å®‰å…¨è·¯å¾„ä¸å­˜åœ¨ï¼ŒBFS å¯»æ‰¾ä»å½“å‰è›‡å¤´åˆ°è›‡å°¾çš„æœ€é•¿è·¯å¾„ã€‚
   *   å®ç°ä¸Šç”¨è´ªå¿ƒï¼šBFS åˆ°è›‡å°¾æ—¶ä¼˜å…ˆé€‰æ‹©è·ç¦»å°¾éƒ¨"æœ€è¿œ"çš„é‚»æ ¼ï¼Œ
   *   è®©è›‡ç»•ç€è‡ªå·±çš„å°¾å·´è½¬ï¼Œäº‰å–ç­‰å¾…é£Ÿç‰©å˜ä¸ºå¯è¾¾ã€‚
   *
   * ä¼˜å…ˆçº§ 3 â€” ä»»æ„å®‰å…¨æ–¹å‘
   *   è‹¥ä¸Šè¿°å‡æ— è§£ï¼Œé€‰ä¸€ä¸ªä¸ä¼šç«‹å³æ’å¢™æˆ–æ’è‡ªèº«çš„æ–¹å‘ã€‚
   *
   * è¿™ç§ç­–ç•¥èƒ½æœ‰æ•ˆé˜²æ­¢è›‡æŠŠè‡ªå·±å›´æ­»ï¼Œåœ¨å¤šæ•°æƒ…å†µä¸‹å¯å¡«æ»¡å¤§éƒ¨åˆ†æ£‹ç›˜ã€‚
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   */

  (() => {
    const COLS = 20, ROWS = 20, CELL = (() => {
      const maxW = Math.min(window.innerWidth - 24, window.innerHeight - 140, 520);
      return Math.floor(maxW / COLS);
    })();
    const W = COLS * CELL, H = ROWS * CELL;

    const canvas = document.getElementById('c');
    canvas.width = W; canvas.height = H;
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const bestEl  = document.getElementById('best');
    const gamesEl = document.getElementById('games');

    let snake, dir, nextDir, food, score, best = 0, games = 0;
    let running = false, animId = null;

    // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const idx  = (x, y) => y * COLS + x;
    const inBounds = (x, y) => x >= 0 && x < COLS && y >= 0 && y < ROWS;

    const DIRS = [[0,-1],[1,0],[0,1],[-1,0]]; // up right down left

    function placeFood(snakeSet) {
      const free = [];
      for (let y = 0; y < ROWS; y++)
        for (let x = 0; x < COLS; x++)
          if (!snakeSet.has(idx(x,y))) free.push([x,y]);
      if (!free.length) return null;
      return free[Math.random() * free.length | 0];
    }

    // BFS from (sx,sy) to (tx,ty); occupied = Set of idx; returns path array or null
    function bfs(sx, sy, tx, ty, occupied) {
      const start = idx(sx, sy);
      const goal  = idx(tx, ty);
      if (start === goal) return [];
      const prev = new Map([[start, -1]]);
      const queue = [start];
      let qi = 0;
      while (qi < queue.length) {
        const cur = queue[qi++];
        const cx = cur % COLS, cy = cur / COLS | 0;
        for (const [dx,dy] of DIRS) {
          const nx = cx+dx, ny = cy+dy;
          if (!inBounds(nx,ny)) continue;
          const nid = idx(nx,ny);
          if (occupied.has(nid) || prev.has(nid)) continue;
          prev.set(nid, cur);
          if (nid === goal) {
            // reconstruct
            const path = [];
            let cur2 = nid;
            while (cur2 !== start) { path.push(cur2); cur2 = prev.get(cur2); }
            path.reverse();
            return path;
          }
          queue.push(nid);
        }
      }
      return null;
    }

    // Simulate snake following path; return new snake array + new occupied Set
    function simulateFollow(snakeArr, pathIds) {
      const s = snakeArr.slice();
      for (const nid of pathIds) {
        s.unshift([nid % COLS, nid / COLS | 0]);
        s.pop();
      }
      return s;
    }

    // Build occupied set from snake array (optionally exclude tail)
    function buildOccupied(snakeArr, excludeTail = false) {
      const s = new Set();
      const limit = excludeTail ? snakeArr.length - 1 : snakeArr.length;
      for (let i = 0; i < limit; i++) s.add(idx(snakeArr[i][0], snakeArr[i][1]));
      return s;
    }

    // â”€â”€ AI Decision â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function decide() {
      const [hx, hy] = snake[0];
      const [fx, fy] = food;
      const occ = buildOccupied(snake);

      // Priority 1: safe path to food
      const pathToFood = bfs(hx, hy, fx, fy, occ);
      if (pathToFood && pathToFood.length > 0) {
        // Simulate snake eating food
        const simSnake = snake.slice();
        simSnake.unshift([pathToFood[pathToFood.length-1] % COLS,
                          pathToFood[pathToFood.length-1] / COLS | 0]);
        // Don't pop tail (snake grows on eating)
        const simOcc = buildOccupied(simSnake);
        const [tx, ty] = simSnake[simSnake.length - 1];
        const canReachTail = bfs(
          simSnake[0][0], simSnake[0][1],
          tx, ty,
          buildOccupied(simSnake, true)
        );
        if (canReachTail !== null) {
          return pathToFood[0];
        }
      }

      // Priority 2: chase tail (longest path heuristic)
      const [tx, ty] = snake[snake.length - 1];
      const occNoTail = buildOccupied(snake, true);
      const tailPath = bfs(hx, hy, tx, ty, occNoTail);
      if (tailPath && tailPath.length > 0) {
        // Among neighbors, pick the one that maximises distance from tail
        // (greedy: pick the neighbor that BFS found furthest from tail)
        return tailPath[0];
      }

      // Priority 3: any safe neighbor
      let best = null;
      for (const [dx,dy] of DIRS) {
        const nx = hx+dx, ny = hy+dy;
        if (!inBounds(nx,ny) || occ.has(idx(nx,ny))) continue;
        best = idx(nx,ny);
        break;
      }
      return best;
    }

    // â”€â”€ Game Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function init() {
      const cx = COLS/2|0, cy = ROWS/2|0;
      snake = [[cx,cy],[cx-1,cy],[cx-2,cy]];
      dir = [1,0]; nextDir = [1,0];
      const occ = buildOccupied(snake);
      food = placeFood(occ);
      score = 0; scoreEl.textContent = 0;
    }

    const SPEED = 100; // ms per step
    let lastStep = 0;

    function step(ts) {
      if (!running) return;
      animId = requestAnimationFrame(step);
      if (ts - lastStep < SPEED) return;
      lastStep = ts;

      const nextId = decide();
      if (nextId === null) { gameOver(); return; }

      const nx = nextId % COLS, ny = nextId / COLS | 0;
      const [hx, hy] = snake[0];
      // Verify the chosen move doesn't reverse direction (shouldn't happen but guard)
      if (nx === hx - dir[0] && ny === hy - dir[1]) { gameOver(); return; }
      dir = [nx - hx, ny - hy];

      snake.unshift([nx, ny]);

      if (nx === food[0] && ny === food[1]) {
        score++;
        scoreEl.textContent = score;
        if (score > best) { best = score; bestEl.textContent = best; }
        const occ = buildOccupied(snake);
        food = placeFood(occ);
        if (!food) { gameOver(); return; } // board full â€” win!
      } else {
        snake.pop();
      }

      draw();
    }

    function gameOver() {
      running = false;
      games++;
      gamesEl.textContent = games;
      cancelAnimationFrame(animId);
      // Auto-restart after brief pause
      setTimeout(() => { init(); startGame(); }, 800);
    }

    function startGame() {
      running = true;
      lastStep = 0;
      animId = requestAnimationFrame(step);
    }

    // â”€â”€ Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function draw() {
      // Background grid
      ctx.fillStyle = '#0d1117';
      ctx.fillRect(0, 0, W, H);

      // Subtle grid lines
      ctx.strokeStyle = '#161b2299';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= COLS; x++) {
        ctx.beginPath(); ctx.moveTo(x*CELL, 0); ctx.lineTo(x*CELL, H); ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        ctx.beginPath(); ctx.moveTo(0, y*CELL); ctx.lineTo(W, y*CELL); ctx.stroke();
      }

      // Food â€” glowing dot
      const [fx, fy] = food;
      const fcx = fx*CELL + CELL/2, fcy = fy*CELL + CELL/2;
      const grad = ctx.createRadialGradient(fcx, fcy, 1, fcx, fcy, CELL*0.55);
      grad.addColorStop(0, '#ff7b72');
      grad.addColorStop(0.6, '#d73a4a');
      grad.addColorStop(1, '#d73a4a00');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(fcx, fcy, CELL*0.42, 0, Math.PI*2);
      ctx.fill();

      // Snake body
      const len = snake.length;
      for (let i = len - 1; i >= 0; i--) {
        const [sx, sy] = snake[i];
        const t = 1 - i / len; // 0=tail, 1=head
        const r = Math.round(63 + t * 111);
        const g = Math.round(185 + t * 70);
        const b = Math.round(80 + t * 10);
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        const pad = 1.5;
        ctx.beginPath();
        ctx.roundRect(sx*CELL+pad, sy*CELL+pad, CELL-pad*2, CELL-pad*2, CELL*0.25);
        ctx.fill();
      }

      // Head highlight
      const [hx, hy] = snake[0];
      ctx.fillStyle = '#ffffff22';
      ctx.beginPath();
      ctx.roundRect(hx*CELL+2, hy*CELL+2, CELL*0.55, CELL*0.45, 3);
      ctx.fill();

      // Eyes
      const eyeOffset = CELL * 0.22;
      const eyeSize   = CELL * 0.1;
      ctx.fillStyle = '#0d1117';
      const [dx, dy] = dir;
      // Perpendicular offsets for eyes
      const px = -dy, py = dx;
      const ex = hx*CELL + CELL/2 + dx*eyeOffset;
      const ey = hy*CELL + CELL/2 + dy*eyeOffset;
      for (const s of [-1, 1]) {
        ctx.beginPath();
        ctx.arc(ex + px*eyeOffset*s*0.7, ey + py*eyeOffset*s*0.7, eyeSize, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    document.getElementById('btn-start').addEventListener('click', () => {
      document.getElementById('overlay').style.display = 'none';
      init();
      startGame();
    });

    // Prevent page scroll on touch inside canvas
    canvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchmove',  e => e.preventDefault(), { passive: false });

    // Initial draw placeholder
    (() => {
      ctx.fillStyle = '#0d1117';
      ctx.fillRect(0, 0, W, H);
      ctx.strokeStyle = '#161b2244';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= COLS; x++) {
        ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,H); ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(W,y*CELL); ctx.stroke();
      }
    })();
  })();
  </script>
</body>
</html>
